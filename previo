from multiprocessing import Process
from multiprocessing import BoundedSemaphore, Semaphore, Lock
from multiprocessing import current_process
from multiprocessing import Value, Array
from time import sleep
import random


N = 5 #cuantos numeros generan
K = 3 #tamaño de las listas
NPROD = 3 #numero de productores




#añade un elemento a la lista
#igual es buena idea usar el pid para acceder al indice y data 
#de cada proceso guardados en una lista

        
def remove_data(storage,index, pid,empty):
    
    try:
        storage[index]=-2
        empty.release()
    finally:
        pass
        

        
def min_indice(lst):
    minimo = min(lst)
    indice = lst.index(minimo)    
    return (indice, minimo)
  

def delay(factor = 3):
    sleep(random.random()/factor)



def producer(array,data, index, empty, non_empty):
    for v in range(N):
        
        empty.acquire()
        if data==-2:
            data= random.randint(0,5)
        else :
            data= data+ random.randint(0,5)
        index_lista= index % K
        
        array[index_lista]=data
        
        non_empty.release()
        
        index= index + 1
        
    data= -1
    index_lista= index % K 
    array[index_lista]=-1

# Esto va a ser el merge
def consumer_merge(storage,ordenada, index_cons, empty_lst, non_empty_lst):
    parada=[-2]*NPROD
    menos_unos=[-1]*NPROD
   
    while parada != menos_unos:
        for non_empty in non_empty_lst:
            non_empty.acquire()
        c=0
        primer_elem=[None]*NPROD
        for array in storage:
            indice=index_cons[c]
            elemento=array[indice]
            if elemento != -1:
                primer_elem[c]=elemento
            else:
                primer_elem[c]=float('inf')
            c+=1
            

        (i,minimo)=min_indice(primer_elem)
        
        indice = index_cons[i] % K
        
        remove_data(storage[i], indice, i , empty_lst[i])
        
        index_cons[i]=index_cons[i]+1
       
        ordenada.append(minimo)
        
        
        for j in range(i):
            non_empty_lst[i].release()
            
        for j in range(i+1,NPROD):
            non_empty_lst[i].release()
        c=0    
        for array in storage:
            indice=index_cons[c]
            elemento=array[indice]
            parada[c]=elemento
            c+=1
        
        
        
        print (f"consumer {current_process().name} ordenando {ordenada}")
        delay()

def main():
    storage=[Array("i",K) for _ in range(NPROD)]
    ordenada= []
    index_cons = [0]*NPROD
    
    
    for lista in storage:
        for i in range(K):
            lista[i]=-2
        
       
    

    
    non_empty_lst= [None]*NPROD
    for i in range(NPROD):
        non_empty_lst[i] = Semaphore(0)
    empty_lst= [None]*NPROD
    for i in range(NPROD):
        empty_lst[i] = BoundedSemaphore(K)
    
    
    

    prodlst = [ Process(target=producer,
                        name=f'prod_{i}',
                        args=(storage[i],-2, 0, empty_lst[i], non_empty_lst[i]))
                for i in range(NPROD) ]

    conslst = [ Process(target=consumer_merge,
                      name="cons",
                      args=(storage,ordenada, index_cons, empty_lst, non_empty_lst))]

    for p in prodlst + conslst:
        p.start()

    for p in prodlst + conslst:
        p.join()


if __name__ == '__main__':
    main()



